package corpus;

import java.io.*;
import java.util.*;

public class TrainCorpusGeneration {

	/**
	 * @param args
	 */
	
	public static void main(String[] args) throws Exception{
		// TODO Auto-generated method stub
		// source language
		BufferedReader in_e = new BufferedReader(
				new InputStreamReader(
						new FileInputStream(args[0]), "UTF-8"));
		//target language
		BufferedReader in_f = new BufferedReader(
				new InputStreamReader(
						new FileInputStream(args[1]), "UTF-8"));
		//align file
		BufferedReader in_align = new BufferedReader(
				new InputStreamReader(
						new FileInputStream(args[2]), "UTF-8"));
		// output file
		PrintWriter writer = new PrintWriter(new OutputStreamWriter(
				new FileOutputStream(args[3]), "UTF-8"));	
		
		String eline, fline, alignline;
		while( (eline = in_e.readLine()) != null &&
			   (fline = in_f.readLine()) != null &&
			   (alignline = in_align.readLine()) != null
				)
		{
			String[] aligns = alignline.trim().split("\\s+");
			List<Set<Integer>> target2source = new ArrayList<Set<Integer>>();
			String[] target_words = fline.trim().split("\\s+");
			String[] source_words = eline.trim().split("\\s+");
			for(int idx = 0; idx < target_words.length; idx++)
			{
				target2source.add(new HashSet<Integer>());
			}
			Set<Integer> nullSources = new HashSet<Integer>();
			for(int idx = 0; idx < aligns.length; idx++)
			{
				int source_id = Integer.parseInt(aligns[idx]);
				int target_id = Integer.parseInt(aligns[idx+1]);
				idx++;
				if(target_id >= 0)
				{
					target2source.get(target_id).add(source_id);
				}
				else
				{
					if(target_id != -1)
					{
						System.out.println("error align ....");
					}
					nullSources.add(source_id);
				}
			}
			
			//check
			
			boolean bValidAlign = true;
			PhraseSplit[] phrases = new PhraseSplit[target_words.length];
			int phrase_size = 0;
			for(int idx = 0; idx < target_words.length; idx++)
			{
				Set<Integer> curCollect = target2source.get(idx);
				if(curCollect.size() == 0)continue;
				int max = -1;
				int min = source_words.length;
				for(Integer curSeq : curCollect)
				{
					if(min > curSeq)  min = curSeq;
					if(max < curSeq)  max = curSeq;
				}
				
				for(int idy = min+1; idy < max; idy++)
				{
					if(!curCollect.contains(idy))
					{
						bValidAlign = false;
						break;
					}
				}
				
				if(!bValidAlign)
				{
					System.out.println(curCollect);
					break;
				}
				else
				{
					//Split[min] = true;
					PhraseSplit current = new PhraseSplit(min, max);
					int idy = 0;
					int lastcompare = -1;
					for(; idy < phrase_size; idy++)
					{
						lastcompare = phrases[idy].compare(current);
						if(lastcompare >= 0) break;
					}
					if(lastcompare != 0)
					{
						for(int idk = phrase_size; idk > idy; idk--)
						{
							phrases[idk] = phrases[idk-1];
						}
						phrases[idy] = current;
						phrase_size++;
					}
				}
			}
			
			
			boolean[] bSplit = new boolean[source_words.length];
			for(int idx = 0; idx < source_words.length; idx++)
			{
				bSplit[idx] = false;
			}
			
			for(int idx = 0; idx < phrase_size; idx++)
			{
				int min = phrases[idx].start;
				int max = phrases[idx].end;
				while(idx < phrase_size - 1 && max >= phrases[idx+1].start)
				{
					idx++;
					if(max < phrases[idx].end)max = phrases[idx].end;
				}
				bSplit[min] = true;
				int next_start = source_words.length;
				if(idx < phrase_size - 1) next_start = phrases[idx+1].start;
				for(int idy = max+1; idy < next_start; idy++)
				{
					if(nullSources.contains(idy))
					{
						bSplit[idy]=true;
					}
					else
					{
						System.out.println("error align.....");
					}
				}
			}
			
			
			int index = 0;
			assert(bSplit[0] == true);
			int[] nNewSequence = new int[source_words.length];
			nNewSequence[0] = 0;
			for(int idx = 1; idx < source_words.length; idx++)
			{
				if(bSplit[idx])
				{
					index++;
				}
				nNewSequence[idx] = index;
			}
			
			// phrase-based seq, not the word based seq
			// earch target word should align to one phrase-based seq
			// otherwise the target word is generated by NULL
			int[] alignresults = new int[target_words.length];
			
			for(int idx = 0; idx < target_words.length; idx++)
			{
				alignresults[idx] = -1;
			}
			
			for(int idx = 0; idx < aligns.length; idx++)
			{
				int source_id = Integer.parseInt(aligns[idx]);
				int target_id = Integer.parseInt(aligns[idx+1]);
				idx++;
				if(target_id == -1) continue;
				if(alignresults[target_id] == -1)
				{
					alignresults[target_id] = nNewSequence[source_id];
				}
				else
				{
					if(nNewSequence[source_id] != alignresults[target_id])
					{
						bValidAlign = false;
						System.out.println(String.format("%d:%d", source_id, target_id));
					}
				}
			}
			
			
			String source_line = source_words[0];
			
			for(int idx = 1; idx < source_words.length; idx++)
			{
				source_line = source_line + " " + source_words[idx];
			}
			
			writer.println(source_line);
			
			String source_line_splitted = "0";
			
			for(int idx = 1; idx < source_words.length; idx++)
			{
				if(bSplit[idx])
				{
					source_line_splitted = source_line_splitted + " " + String.format("%d", idx);
				}
			}
			
			source_line_splitted = source_line_splitted + " " + String.format("%d", source_words.length);
			writer.println(source_line_splitted);
			
			String target_line = target_words[0];
			for(int idx = 1; idx < target_words.length; idx++)
			{
				target_line = target_line + " " + target_words[idx];
			}
			writer.println(target_line);
			
			String target_line_align = String.format("%d", alignresults[0]);
			for(int idx = 1; idx < target_words.length; idx++)
			{
				target_line_align = target_line_align + " " + String.format("%d", alignresults[idx]);
			}
			writer.println(target_line_align);						
			//
		}
		
		
		in_e.close();
		in_f.close();
		in_align.close();
		writer.close();
	}

}
